//! SMTP client library, implements builder variant and standard initialisation.
//! 
//! Basic usage is a builder pattern with you initalising with the required fields then specifying other's as required.
//! Below example creates an Smtp struct then adds the data required to send a txt file and log into an smtp server that requires Username and Password
//! ```no_run
//!     use smtpclient::{SmtpBuilder, ContentType};
//!     let smtp_client_builder = SmtpBuilder::new(
//!         "host".to_string(),  
//!         "port".to_string(), 
//!         "sender".to_string(), 
//!         "recipient".to_string(), 
//!         "domain".to_string()
//!         );
//! 
//!         smtp_client_builder
//!         .subject("Email Subject".to_string())
//!         .body("This is a body - Generated by builder\nCan I have 한글? 안녕하세요~~".to_string())
//!         .display_name("Who I am".to_string())
//!         .login("username".to_string(), "password".to_string())
//!         .attach("test.txt".to_string(), ContentType::TextPlain).unwrap()
//!         .starttls()
//!         .send().unwrap(); 
//! ```
//! 
//! ### TODO:
//! - ~~Add builder~~
//! - ~~Unit Tests~~
//! - ~~Convert to lib~~
//! - Compare to powershell
//! - Re design stream reads to be more strict requiring \r\n
//! - Split out into more files
//! - Move read/write out of the struct
//! - Move the tcp/tls streams out of the struct
//! - ~~Env Variables~~
//! - ~~한글~~
//! 
use std::io::prelude::{Read, Write};
use std::vec::Vec;

pub mod stream;
use stream::Stream;

pub mod error;
use crate::error::{Result, Error};

mod types;
pub use types::{ContentType, StatusCodes};
static CRLF: &str = "\r\n";

/// This is the struct that contains the fields required to send an email and Options for the others, \
/// it also contains the handles for the TCP and TLS streams once connected.
/// 
/// # Required Fields
/// - host
/// - port
/// - sender
/// - recipient
/// - sender_domain
/// 
/// # Internal Use
/// - stream
/// - tls_stream
/// - tls
/// 
#[allow(dead_code)]
pub struct SmtpBuilder{
    pub host: String, 
    pub port: String, 
    pub sender: String, 
    pub recipient: String, 
    pub sender_domain: String,
    display_name: Option<String>,
    subject: Option<String>,
    body: Option<String>,
    username: Option<String>,
    password: Option<String>,
    attachment: Option<Vec<u8>>,
    filename: Option<String>,
    attachment_content_type: Option<ContentType>,
    body_content_type: ContentType,
    tls: bool,
    auth_plain: bool,
    auth_login: bool,
    raw_bytes: Vec<u8>,
}

#[allow(dead_code)]
impl SmtpBuilder{
    pub fn new(
        host: String, 
        port: String, 
        sender: String, 
        recipient: String, 
        sender_domain: String) -> Self{
        Self{
            host,
            port,
            sender,
            recipient,
            sender_domain,
            display_name: None,
            subject: None,
            body: None,
            username: None,
            password: None,
            tls: false,
            auth_plain: false,
            auth_login: false,
            attachment: None,
            filename: None,
            attachment_content_type: None,
            body_content_type: ContentType::TextPlain,
            raw_bytes: Vec::new(),
        }
    }
    
    /// Add subject to email (Optional)
    /// 
    pub fn subject(mut self, subject: String) -> Self{
        self.subject = Some(subject);
        self
    }

    /// Add body to email (Optional)
    /// 
    pub fn body(mut self, body: String) -> Self{
        self.body = Some(body);
        self
    }

    /// Add display name to email (Optional)
    /// 
    pub fn display_name(mut self, display_name: String) -> Self{
        self.display_name = Some(display_name);
        self
    }

    /// Used to pass the username and password for the SMTP authentication which we base64 encode before sending (Optional)
    /// 
    pub fn auth_login(mut self, username: String, password: String) -> Self{
        self.auth_login = true;
        self.username = Some(base64::encode(username));
        self.password = Some(base64::encode(password));
        self
    }
    /// Used to pass the username and password for the SMTP authentication which we base64 encode before sending (Optional)
    /// 
    pub fn auth_plain(mut self, username: String) -> Self{
        self.auth_plain = true;
        self.username = Some(username);
        self
    }
    /// Used to pass the base64 encoded username and base64 encoded password for the SMTP authentication (Optional)
    /// 
    pub fn html_body(mut self) -> Self{
        self.body_content_type = ContentType::TextHTML;
        self
    }
    /// Pass a file name to the SMTP builder to attach it to an email, requires filename and [ContentType] (Optional)
    /// # Example
    /// ```rust
    ///     # use smtpclient::*;
    //
    ///     let Builder = SmtpBuilder::new(
    ///         "host".to_string(),  
    ///         "port".to_string(), 
    ///         "sender".to_string(), 
    ///         "recipient".to_string(), 
    ///         "domain".to_string()
    ///         );
    ///     Builder.attach("Cat.jpg".to_string(), ContentType::ImageJpeg);
    /// ```
    /// 
    pub fn attach(mut self, file: String, content_type: ContentType) -> Result<Self>{
        let buffer = &mut Vec::new();
        let mut stream = std::io::BufReader::new(std::fs::File::open(file.to_owned()).map_err(Error::OpenFile)?);

        stream.read_to_end(buffer).map_err(Error::IO)?;

        self.filename = Some(file.to_owned()); 
        self.attachment_content_type = Some(content_type);
        self.attachment = Some(buffer.to_vec());
        Ok(self)
    }
    /// Sends email from raw bytes
    /// 
    pub fn raw_bytes(mut self, bytes: Vec<u8>) -> Self{
        self.raw_bytes = bytes;
        self
    }
    /// Enables the STARTTLS encryption
    /// 
    pub fn starttls(mut self) -> Self {
        self.tls = true;
        self
    }
    /// Internal use, initialises a TCP session with an SMTP server and stores the stream in `self.stream`
    /// 
    fn connect(&self) -> Result<Stream>{
        println!("Connecting to {}:{}...", &self.host, &self.port);
        let mut stream = Stream::new(&self.host, &self.port);

        // Initial connection
        let buffer = stream.read()?;

        println!("S: {:?} from {}:{} ({})", 
            StatusCodes::lookup(&buffer)?,
            &self.host, 
            &self.port, 
            stream.peer_addr());
        Ok(stream)
    }
    /// When called it will send an email based on the builders gathered variables
    /// 
    pub fn send(&self) -> Result<()>{

        // Connect to remote host
        let mut stream = self.connect()?;
        
        // Start TLS if specified by user
        if self.tls {
            self.command(&mut stream, "STARTTLS".into())?;
            stream.start_tls(&self.host).expect("TLS Failed to Connect");
        }

        // EHLO
        self.command(&mut stream, format!("EHLO {}", self.sender_domain))?;

        // Authenticate
        if self.auth_login {
            self.command(&mut stream, "AUTH LOGIN".into())?;
            self.command(&mut stream, self.username.to_owned().unwrap_or("".into()))?;
            self.command(&mut stream, self.password.to_owned().unwrap_or("".into()))?;
        }
        // Authenticate
        if self.auth_plain {
            self.command(&mut stream, format!("AUTH PLAIN {}", self.username.to_owned().unwrap_or("".into())))?;
        }

        // Mail from
        self.command(&mut stream, format!("MAIL FROM: <{}>", self.sender))?;

        // Mail to
        self.command(&mut stream, format!("RCPT TO: <{}>", self.recipient))?;

        // Init Data Send
        self.command(&mut stream, "DATA".into()).unwrap();

        // Email is build field by field, not from raw bytes
        if self.raw_bytes.is_empty(){
            // Send the Data after formatting
            self.command(&mut stream, self.format_data()?)?;
        // Raw bytes are used to send
        }else{
            self.command(&mut stream, String::from_utf8(self.raw_bytes.clone()).unwrap())?;
        }

        // Quit the stream at the end
        self.command(&mut stream, "QUIT".to_string())?;
    
        Ok(())
    }

    /// Used to create a String which will will load into the TCP stream that contains the email
    /// 
    /// **Here be dragons, this needs major refactor**
    /// 
    fn format_data(&self) -> Result<String> {
        let data: String;
        let date = chrono::Utc::now().to_rfc2822();

        if self.attachment.is_some(){      
            let encoded_attachment = base64::encode(self.attachment.as_ref().expect("No attachment found while trying to encode"));
            data = format!(
                "From: {display_name} <{sender}>{CRLF}\
                To: {recipient}{CRLF}\
                MIME-Version: 1.0{CRLF}\
                X-Secret-Header: This is a secret header{CRLF}\
                Date: {date}{CRLF}\
                Subject: {subject}{CRLF}\
                Content-Type: multipart/mixed; boundary=\"BOUNDARY\"{CRLF}{CRLF}\
                --BOUNDARY{CRLF}\
                Content-Type: {body_content_type}; charset=utf-8;{CRLF}\
                Content-Disposition: inline{CRLF}{CRLF}\
                {body}{CRLF}\
                --BOUNDARY{CRLF}\
                Content-Type: {attach_content_type}{CRLF}\
                Content-ID: <1>{CRLF}\
                Content-Disposition: attachment; filename={filename};{CRLF}\
                Content-Transfer-Encoding: {encoding}{CRLF}{CRLF}\
                {attachment}\
                {CRLF}--BOUNDARY--{CRLF}\
                .",
                attachment = encoded_attachment,
                display_name = self.display_name.to_owned().unwrap_or("".into()), 
                sender = self.sender, 
                recipient = self.recipient,
                date = date,
                subject = self.subject.to_owned().unwrap_or("".into()),
                body = self.body.to_owned().unwrap_or("".into()),
                body_content_type = self.body_content_type,
                attach_content_type = self.attachment_content_type.as_ref().unwrap_or(&ContentType::ImageJpeg),
                filename = self.filename.to_owned().unwrap_or("".into()),
                encoding = "Base64".to_string(),
                CRLF = CRLF,
            );
        }
        else{
            data = format!(
                "From: {display_name} <{sender}>{CRLF}\
                To: {recipient}{CRLF}\
                Date: {date}{CRLF}\
                X-Secret-Header: This is a secret header{CRLF}\
                Content-Type: {body_content_type}; charset=utf-8;{CRLF}\
                Subject: {subject}{CRLF}{CRLF}\
                {body}{CRLF}\
                .", 
                display_name = self.display_name.to_owned().unwrap_or("".into()), 
                sender = self.sender, 
                recipient = self.recipient,
                date = date,
                body_content_type = self.body_content_type,
                subject = self.subject.to_owned().unwrap_or("".into()),
                body = self.body.to_owned().unwrap_or("".into()),
                CRLF = CRLF,
            );
        }

        Ok(data)
    }

    fn command(&self, stream: &mut Stream, msg: String) -> Result<StatusCodes>{

        if msg.find("From: ").is_none(){
            println!("C: \"{}\" to {}:{}", msg, self.host, self.port);
        }else{
            println!("Sending data to {}:{}, saved to out.log", self.host, self.port);
            let mut file = std::fs::File::create("out.log").map_err(Error::IO)?;
            file.write_all(msg.as_bytes()).map_err(Error::IO)?;
        }
        stream.write(msg)?;
        let buffer = stream.read()?;

        let status = StatusCodes::lookup(&buffer)?;
        println!("S: {:?} from {}:{}", status, self.host, self.port);

        Ok(status)
    }
}

#[cfg(test)]
mod test;
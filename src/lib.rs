//! SMTP client library, implements builder variant and standard initialisation.
//! 
//! Basic usage is a builder pattern with you initalising with the required fields then specifying other's as required.
//! Below example creates an Smtp struct then adds the data required to send a txt file and log into an smtp server that requires Username and Password
//! ```no_run
//!     use smtpclient::{SmtpBuilder, ContentType};
//!     let smtp_client_builder = SmtpBuilder::new(
//!         "host".to_string(),  
//!         "port".to_string(), 
//!         "sender".to_string(), 
//!         "recipient".to_string(), 
//!         "domain".to_string()
//!         );
//! 
//!         smtp_client_builder
//!         .subject("Email Subject".to_string())
//!         .body("This is a body - Generated by builder\nCan I have 한글? 안녕하세요~~".to_string())
//!         .display_name("Who I am".to_string())
//!         .login("username".to_string(), "password".to_string())
//!         .attach("test.txt".to_string(), ContentType::TextPlain).unwrap()
//!         .starttls()
//!         .send().unwrap(); 
//! ```
//! 
//! ### TODO:
//! - ~~Add builder~~
//! - ~~Unit Tests~~
//! - ~~Convert to lib~~
//! - Compare to powershell
//! - Re design stream reads to be more strict requiring \r\n
//! - Split out into more files
//! - Move read/write out of the struct
//! - Move the tcp/tls streams out of the struct
//! - ~~Env Variables~~
//! - ~~한글~~
//! 
use std::net::TcpStream;
use std::io::prelude::{Read, Write, BufRead};
use std::io::BufReader;
use std::vec::Vec;

use native_tls::{TlsConnector, TlsStream};

mod error;
use crate::error::{Result, Error};
mod types;
pub use types::{ContentType, StatusCodes};

static CRLF: &str = "\r\n";

/// This is the struct that contains the fields required to send an email and Options for the others, \
/// it also contains the handles for the TCP and TLS streams once connected.
/// 
/// # Required Fields
/// - host
/// - port
/// - sender
/// - recipient
/// - sender_domain
/// 
/// # Internal Use
/// - stream
/// - tls_stream
/// - tls
/// 
#[allow(dead_code)]
pub struct SmtpBuilder{
    pub host: String, 
    pub port: String, 
    pub sender: String, 
    pub recipient: String, 
    pub sender_domain: String,
    display_name: Option<String>,
    subject: Option<String>,
    body: Option<String>,
    username: Option<String>,
    password: Option<String>,
    attachment: Option<Vec<u8>>,
    filename: Option<String>,
    attachment_content_type: Option<ContentType>,
    body_content_type: ContentType,
    stream: Option<TcpStream>,
    tls_stream: Option<TlsStream<TcpStream>>,
    tls: bool,
    auth_plain: bool,
    auth_login: bool,
    raw_bytes: Vec<u8>,
}

impl Drop for SmtpBuilder{
    fn drop(&mut self){
        // Quit if Tcp stream is Some(TCPStream) or Some(TLSStream)
        if self.stream.is_some() || self.tls_stream.is_some() {
            match self.command("QUIT".to_string()) {
                Ok(StatusCodes::ServiceClosed) => {
                    // Need this to complete the tcp connection when its TLS with a correct FIN rather than RST, not sure why
                    if self.tls_stream.is_some(){
                        self.tls_stream.as_mut().unwrap().read_to_end(&mut vec![]).unwrap_or_default();
                    }
                }  
                _ => println!("Could not Quit session: {:?}", self.stream.as_ref().unwrap())
            };
        } else { println!("Dropping session to {}:{} without establishing", self.host, self.port) }    
    }
}

#[allow(dead_code)]
impl SmtpBuilder{
    pub fn new(
        host: String, 
        port: String, 
        sender: String, 
        recipient: String, 
        sender_domain: String) -> Self{
        Self{
            host,
            port,
            sender,
            recipient,
            display_name: None,
            sender_domain,
            subject: None,
            body: None,
            username: None,
            password: None,
            stream: None,
            tls_stream: None,
            tls: false,
            auth_plain: false,
            auth_login: false,
            attachment: None,
            filename: None,
            attachment_content_type: None,
            body_content_type: ContentType::TextPlain,
            raw_bytes: Vec::new(),
        }
    }
    
    /// Add subject to email (Optional)
    /// 
    pub fn subject(mut self, subject: String) -> Self{
        self.subject = Some(subject);
        self
    }

    /// Add body to email (Optional)
    /// 
    pub fn body(mut self, body: String) -> Self{
        self.body = Some(body);
        self
    }

    /// Add display name to email (Optional)
    /// 
    pub fn display_name(mut self, display_name: String) -> Self{
        self.display_name = Some(display_name);
        self
    }

    /// Used to pass the username and password for the SMTP authentication which we base64 encode before sending (Optional)
    /// 
    pub fn auth_login(mut self, username: String, password: String) -> Self{
        self.auth_login = true;
        self.username = Some(base64::encode(username));
        self.password = Some(base64::encode(password));
        self
    }
    /// Used to pass the username and password for the SMTP authentication which we base64 encode before sending (Optional)
    /// 
    pub fn auth_plain(mut self, username: String) -> Self{
        self.auth_plain = true;
        self.username = Some(username);
        self
    }
    /// Used to pass the base64 encoded username and base64 encoded password for the SMTP authentication (Optional)
    /// 
    pub fn html_body(mut self) -> Self{
        self.body_content_type = ContentType::TextHTML;
        self
    }
    /// Pass a file name to the SMTP builder to attach it to an email, requires filename and [ContentType] (Optional)
    /// # Example
    /// ```rust
    ///     # use smtpclient::*;
    //
    ///     let Builder = SmtpBuilder::new(
    ///         "host".to_string(),  
    ///         "port".to_string(), 
    ///         "sender".to_string(), 
    ///         "recipient".to_string(), 
    ///         "domain".to_string()
    ///         );
    ///     Builder.attach("Cat.jpg".to_string(), ContentType::ImageJpeg);
    /// ```
    /// 
    pub fn attach(mut self, file: String, content_type: ContentType) -> Result<Self>{
        let buf = &mut Vec::new();
        let mut stream = std::io::BufReader::new(std::fs::File::open(file.to_owned()).map_err(Error::OpenFile)?);

        stream.read_to_end(buf).map_err(Error::IO)?;

        self.filename = Some(file.to_owned()); 
        self.attachment_content_type = Some(content_type);
        self.attachment = Some(buf.to_vec());
        Ok(self)
    }
    /// Sends email from raw bytes
    /// 
    pub fn raw_bytes(mut self, bytes: Vec<u8>) -> Self{
        self.raw_bytes = bytes;
        self
    }
    /// Enables the STARTTLS encryption
    /// 
    pub fn starttls(mut self) -> Self {
        self.tls = true;
        self
    }
    /// Internal use, initialises a TCP session with an SMTP server and stores the stream in `self.stream`
    /// 
    fn connect(&mut self) -> Result<()>{
        //let buf = &mut [0u8; 250];
        use std::net::ToSocketAddrs;
        println!("Connecting to {}:{}...", self.host, self.port);
        let sock = format!("{}:{}", self.host, self.port).to_socket_addrs().unwrap().next().unwrap();
        self.stream = Some(TcpStream::connect_timeout(&sock, std::time::Duration::from_secs(5)).map_err(Error::IO)?);

        // Initial connection
        //self.stream.as_ref().ok_or(Error::TCPStreamNotFound)?.read(buf).map_err(Error::IO)?;
        let buf = self.read_stream()?;

        println!("S: {:?} from {}:{} ({})", 
            StatusCodes::lookup(&buf)?, 
            self.host, 
            self.port, 
            self.stream.as_ref().ok_or(Error::TCPStreamNotFound)?.peer_addr().map_err(Error::IO)?);
        Ok(())
    }

    /// Internal use, uses external crate native_tls to start a TLS session inside our existing TCP stream and stores in `self.tls_stream`
    /// 
    pub fn start_tls(&mut self) -> Result<()>{

        self.command("STARTTLS".into())?;
        let tls_connector = TlsConnector::new().map_err(Error::TLS)?;
        let stream = self.stream.take().ok_or(Error::TCPStreamNotFound)?;
        self.tls_stream = Some(tls_connector.connect(self.host.as_str(), stream).map_err(Error::Handshake)?);
        Ok(())
    }

    /// This function reads a TCP stream until a CLRF `[13, 10]` is sent then collects into a [Vec]
    fn read_stream(&mut self) -> Result<Vec<u8>> {

        if self.tls && self.tls_stream.is_some() {
            let mut reader = BufReader::new(self.tls_stream.as_mut().unwrap());
            let mut data: Vec<u8> = vec![];
    
            loop{
                let buffer = reader.fill_buf();      
                match buffer {
                    Ok(bytes) => {
                        let length = bytes.len();
                        data.extend_from_slice(bytes); 
                        reader.consume(length);
                        // Okay checks for CLFR if more than one byte is in buffer
                        if (data.len() > 1) && (&data[data.len()-2..] == [13, 10]){
                            break;
                        }
                    },
                    _ => {}
                }      
            }
            Ok(data)
        }else{
            let mut reader = BufReader::new(self.stream.as_ref().unwrap());
            let mut data: Vec<u8> = vec![];
    
            loop{
                let buffer = reader.fill_buf();      
                match buffer {
                    Ok(bytes) => {
                        let length = bytes.len();
                        data.extend_from_slice(bytes); 
                        reader.consume(length);
                        // Okay checks for CLFR if more than one byte is in buffer
                        if (data.len() > 1) && (&data[data.len()-2..] == [13, 10]){
                            break;
                        }
                    },
                    _ => {}
                }      
            }
            Ok(data)
        }
    }

    /// wrapper around std::io::write for my streams
    fn write_stream(&mut self, msg: String) -> Result<()> {
        if self.tls_stream.is_some(){
            self.tls_stream.as_mut().ok_or(Error::TLSStreamNotFound)?.write_all((msg+CRLF).as_bytes()).map_err(Error::IO)?;
        } else{
            self.stream.as_mut().ok_or(Error::TLSStreamNotFound)?.write_all((msg+CRLF).as_bytes()).map_err(Error::IO)?;
        }
        Ok(())
    }

    /// When called it will send an email based on the builders gathered variables
    /// 
    pub fn send(&mut self) -> Result<()>{

        // Connect to remote host
        self.connect()?;
        
        // Start TLS if specified by user
        if self.tls {
            self.start_tls().expect("TLS Failed to Connect");
        }

        // EHLO
        self.command(format!("EHLO {}", self.sender_domain))?;

        // Authenticate
        if self.auth_login {
            self.command("AUTH LOGIN".into())?;
            self.command(self.username.to_owned().unwrap_or("".into()))?;
            self.command(self.password.to_owned().unwrap_or("".into()))?;
        }
        // Authenticate
        if self.auth_plain {
            self.command(format!("AUTH PLAIN {}", self.username.to_owned().unwrap_or("".into())))?;
        }

        // Mail from
        self.command(format!("MAIL FROM: <{}>", self.sender))?;

        // Mail to
        self.command(format!("RCPT TO: <{}>", self.recipient))?;

        // Init Data Send
        self.command("DATA".into())?;

        if self.raw_bytes.is_empty(){
            // Send the Data after formatting
            self.command(self.format_data()?).expect("Email rejected by forward mail server");
        }else{
            self.command(String::from_utf8(self.raw_bytes.clone()).unwrap()).expect("Email rejected by forward mail server");
        }

        Ok(())
    }

    /// Used to create a String which will will load into the TCP stream that contains the email
    /// 
    /// **Here be dragons, this needs major refactor**
    /// 
    fn format_data(&self) -> Result<String> {
        let data: String;
        let date = chrono::Utc::now().to_rfc2822();

        if self.attachment.is_some(){      
            let encoded_attachment = base64::encode(self.attachment.as_ref().expect("No attachment found while trying to encode"));
            data = format!(
                "From: {display_name} <{sender}>{CRLF}\
                To: {recipient}{CRLF}\
                MIME-Version: 1.0{CRLF}\
                X-Secret-Header: This is a secret header{CRLF}\
                Date: {date}{CRLF}\
                Subject: {subject}{CRLF}\
                Content-Type: multipart/mixed; boundary=\"BOUNDARY\"{CRLF}{CRLF}\
                --BOUNDARY{CRLF}\
                Content-Type: {body_content_type}; charset=utf-8;{CRLF}\
                Content-Disposition: inline{CRLF}{CRLF}\
                {body}{CRLF}\
                --BOUNDARY{CRLF}\
                Content-Type: {attach_content_type}{CRLF}\
                Content-ID: <1>{CRLF}\
                Content-Disposition: attachment; filename={filename};{CRLF}\
                Content-Transfer-Encoding: {encoding}{CRLF}{CRLF}\
                {attachment}\
                {CRLF}--BOUNDARY--{CRLF}\
                .",
                attachment = encoded_attachment,
                display_name = self.display_name.to_owned().unwrap_or("".into()), 
                sender = self.sender, 
                recipient = self.recipient,
                date = date,
                subject = self.subject.to_owned().unwrap_or("".into()),
                body = self.body.to_owned().unwrap_or("".into()),
                body_content_type = self.body_content_type,
                attach_content_type = self.attachment_content_type.as_ref().unwrap_or(&ContentType::ImageJpeg),
                filename = self.filename.to_owned().unwrap_or("".into()),
                encoding = "Base64".to_string(),
                CRLF = CRLF,
            );
        }
        else{
            data = format!(
                "From: {display_name} <{sender}>{CRLF}\
                To: {recipient}{CRLF}\
                Date: {date}{CRLF}\
                X-Secret-Header: This is a secret header{CRLF}\
                Content-Type: {body_content_type}; charset=utf-8;{CRLF}\
                Subject: {subject}{CRLF}{CRLF}\
                {body}{CRLF}\
                .", 
                display_name = self.display_name.to_owned().unwrap_or("".into()), 
                sender = self.sender, 
                recipient = self.recipient,
                date = date,
                body_content_type = self.body_content_type,
                subject = self.subject.to_owned().unwrap_or("".into()),
                body = self.body.to_owned().unwrap_or("".into()),
                CRLF = CRLF,
            );
        }

        Ok(data)
    }

    fn command(&mut self, msg: String) -> Result<StatusCodes>{

        if msg.find("From: ").is_none(){
            println!("C: \"{}\" to {}:{}", msg, self.host, self.port);
        }else{
            println!("Sending data to {}:{}, saved to out.log", self.host, self.port);
            let mut file = std::fs::File::create("out.log").map_err(Error::IO)?;
            file.write_all(msg.as_bytes()).map_err(Error::IO)?;
        }
        self.write_stream(msg)?;
        let buf = self.read_stream()?;

        let status = StatusCodes::lookup(&buf)?;
        println!("S: {:?} from {}:{}", status, self.host, self.port);

        Ok(status)
    }
}

#[cfg(test)]
mod test;